#!/usr/bin/env node

/**
 * Obsidian Plugin Boilerplate Generator
 *
 * Generates minimal, best-practice boilerplate for new Obsidian plugins.
 * Detects existing projects and only adds missing files.
 * All generated code follows the obsidian-plugin-guidelines automatically.
 *
 * Usage:
 *   node create-plugin.js
 *   node create-plugin.js --dir ./my-plugin
 *   node create-plugin.js --id my-plugin --name "My Plugin" --desc "Does something useful."
 */

const fs = require('fs');
const path = require('path');
const readline = require('readline');

const TEMPLATE_FILES = {
  'manifest.json': generateManifest,
  'package.json': generatePackageJson,
  'tsconfig.json': generateTsConfig,
  'esbuild.config.mjs': generateEsbuildConfig,
  'main.ts': generateMainTs,
  'styles.css': generateStylesCss,
  '.eslintrc.json': generateEslintConfig,
  '.gitignore': generateGitignore,
  'versions.json': generateVersionsJson,
};

// --- Validation ---

function validatePluginId(id) {
  const errors = [];
  if (!id || id.trim().length === 0) {
    errors.push('Plugin ID is required.');
  }
  if (/obsidian/i.test(id)) {
    errors.push('Plugin ID must not contain "obsidian".');
  }
  if (/plugin$/i.test(id)) {
    errors.push('Plugin ID must not end with "plugin".');
  }
  if (!/^[a-z0-9-]+$/.test(id)) {
    errors.push('Plugin ID must only contain lowercase letters, numbers, and hyphens.');
  }
  return errors;
}

function validatePluginName(name) {
  const errors = [];
  if (!name || name.trim().length === 0) {
    errors.push('Plugin name is required.');
  }
  if (/obsidian/i.test(name)) {
    errors.push('Plugin name must not contain "Obsidian".');
  }
  if (/plugin$/i.test(name)) {
    errors.push('Plugin name must not end with "Plugin".');
  }
  if (/^obsi/i.test(name)) {
    errors.push('Plugin name must not start with "Obsi".');
  }
  if (/dian$/i.test(name)) {
    errors.push('Plugin name must not end with "dian".');
  }
  return errors;
}

function validateDescription(desc) {
  const errors = [];
  if (!desc || desc.trim().length === 0) {
    errors.push('Description is required.');
  }
  if (/obsidian/i.test(desc)) {
    errors.push('Description must not contain "Obsidian".');
  }
  if (/^(this plugin|a plugin|an obsidian)/i.test(desc)) {
    errors.push('Description must not start with "This plugin", "A plugin", etc.');
  }
  if (!/[.?!)]$/.test(desc.trim())) {
    errors.push('Description must end with punctuation (.?!).');
  }
  return errors;
}

// --- Template generators ---

function generateManifest(config) {
  return JSON.stringify({
    id: config.id,
    name: config.name,
    version: '1.0.0',
    minAppVersion: '0.15.0',
    description: config.description,
    author: config.author,
    authorUrl: config.authorUrl || '',
    isDesktopOnly: false,
  }, null, '\t');
}

function generatePackageJson(config) {
  return JSON.stringify({
    name: config.id,
    version: '1.0.0',
    description: config.description,
    main: 'main.js',
    scripts: {
      dev: 'node esbuild.config.mjs',
      build: 'tsc -noEmit -skipLibCheck && node esbuild.config.mjs production',
      lint: 'eslint . --ext .ts',
      'lint:fix': 'eslint . --ext .ts --fix',
    },
    keywords: [],
    author: config.author,
    license: 'MIT',
    devDependencies: {
      '@types/node': '^16.11.6',
      '@typescript-eslint/eslint-plugin': '^5.29.0',
      '@typescript-eslint/parser': '^5.29.0',
      'builtin-modules': '^3.3.0',
      esbuild: '0.17.3',
      eslint: '^8.20.0',
      'eslint-plugin-obsidianmd': '^latest',
      obsidian: 'latest',
      tslib: '^2.4.0',
      typescript: '4.7.4',
    },
  }, null, '\t');
}

function generateTsConfig() {
  return JSON.stringify({
    compilerOptions: {
      baseUrl: '.',
      inlineSourceMap: true,
      inlineSources: true,
      module: 'ESNext',
      target: 'ES6',
      allowJs: true,
      noImplicitAny: true,
      moduleResolution: 'node',
      importHelpers: true,
      isolatedModules: true,
      strictNullChecks: true,
      lib: ['DOM', 'ES5', 'ES6', 'ES7'],
    },
    include: ['**/*.ts'],
  }, null, '\t');
}

function generateEsbuildConfig() {
  return `import esbuild from "esbuild";
import process from "process";
import builtins from "builtin-modules";

const banner = \`/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
\`;

const prod = process.argv[2] === "production";

const context = await esbuild.context({
\tbannerjs: banner,
\tentryPoints: ["main.ts"],
\tbundle: true,
\texternal: [
\t\t"obsidian",
\t\t"electron",
\t\t"@codemirror/autocomplete",
\t\t"@codemirror/collab",
\t\t"@codemirror/commands",
\t\t"@codemirror/language",
\t\t"@codemirror/lint",
\t\t"@codemirror/search",
\t\t"@codemirror/state",
\t\t"@codemirror/view",
\t\t"@lezer/common",
\t\t"@lezer/highlight",
\t\t"@lezer/lr",
\t\t...builtins,
\t],
\tformat: "cjs",
\ttarget: "es2018",
\tlogLevel: "info",
\tsourcemap: prod ? false : "inline",
\ttreeShaking: true,
\toutfile: "main.js",
\tminify: prod,
});

if (prod) {
\tawait context.rebuild();
\tprocess.exit(0);
} else {
\tawait context.watch();
}
`;
}

function generateMainTs(config) {
  const className = toPascalCase(config.id);
  const settingsName = `${className}Settings`;
  const settingsTabName = `${className}SettingTab`;

  return `import { App, Plugin, PluginSettingTab, Setting } from 'obsidian';

interface ${settingsName} {
\tdateFormat: string;
}

const DEFAULT_SETTINGS: ${settingsName} = {
\tdateFormat: 'YYYY-MM-DD',
};

export default class ${className} extends Plugin {
\tsettings: ${settingsName};

\tasync onload() {
\t\tthis.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());

\t\tthis.addSettingTab(new ${settingsTabName}(this.app, this));
\t}

\tasync saveSettings() {
\t\tawait this.saveData(this.settings);
\t}
}

class ${settingsTabName} extends PluginSettingTab {
\tplugin: ${className};

\tconstructor(app: App, plugin: ${className}) {
\t\tsuper(app, plugin);
\t\tthis.plugin = plugin;
\t}

\tdisplay(): void {
\t\tconst { containerEl } = this;
\t\tcontainerEl.empty();

\t\tnew Setting(containerEl)
\t\t\t.setName('Date format')
\t\t\t.setDesc('Format used when inserting dates.')
\t\t\t.addText((text) =>
\t\t\t\ttext
\t\t\t\t\t.setPlaceholder('YYYY-MM-DD')
\t\t\t\t\t.setValue(this.plugin.settings.dateFormat)
\t\t\t\t\t.onChange(async (value) => {
\t\t\t\t\t\tthis.plugin.settings.dateFormat = value;
\t\t\t\t\t\tawait this.plugin.saveSettings();
\t\t\t\t\t})
\t\t\t);
\t}
}
`;
}

function generateStylesCss(config) {
  const prefix = config.id;
  return `/* Styles for ${config.name} */
/* Use Obsidian CSS variables for theme compatibility */
/* Scope all selectors to your plugin class prefix */

.${prefix}-container {
\tcolor: var(--text-normal);
\tbackground: var(--background-primary);
\tpadding: var(--size-4-4);
}
`;
}

function generateEslintConfig() {
  return JSON.stringify({
    root: true,
    parser: '@typescript-eslint/parser',
    env: { node: true },
    plugins: ['@typescript-eslint', 'obsidianmd'],
    extends: [
      'eslint:recommended',
      'plugin:@typescript-eslint/eslint-recommended',
      'plugin:@typescript-eslint/recommended',
      'plugin:obsidianmd/recommended',
    ],
    parserOptions: {
      sourceType: 'module',
    },
    rules: {
      'no-unused-vars': 'off',
      '@typescript-eslint/no-unused-vars': ['error', { args: 'none' }],
      '@typescript-eslint/ban-ts-comment': 'off',
      'no-prototype-builtins': 'off',
      '@typescript-eslint/no-empty-function': 'off',
    },
  }, null, '\t');
}

function generateGitignore() {
  return `# Build output
main.js
*.js.map

# Node
node_modules/

# IDE
.vscode/
.idea/
*.sublime-*

# OS
.DS_Store
Thumbs.db

# npm
npm-debug.log*

# Obsidian
data.json
`;
}

function generateVersionsJson() {
  return JSON.stringify({
    '1.0.0': '0.15.0',
  }, null, '\t');
}

// --- Helpers ---

function toPascalCase(str) {
  return str
    .split(/[-_]+/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
}

function ask(rl, question) {
  return new Promise((resolve) => {
    rl.question(question, (answer) => resolve(answer.trim()));
  });
}

// --- Main ---

async function main() {
  const args = parseArgs(process.argv.slice(2));
  const targetDir = args.dir || process.cwd();

  console.log('');
  console.log('=== Obsidian Plugin Boilerplate Generator ===');
  console.log('');

  // Detect existing project
  const existingFiles = detectExistingFiles(targetDir);
  if (existingFiles.length > 0) {
    console.log(`Detected existing project in ${targetDir}`);
    console.log(`Existing files: ${existingFiles.join(', ')}`);
    console.log('Only missing files will be generated.');
    console.log('');
  }

  let config;

  if (args.id && args.name && args.desc) {
    // Non-interactive mode
    config = {
      id: args.id,
      name: args.name,
      description: args.desc,
      author: args.author || 'Author Name',
      authorUrl: args.authorUrl || '',
    };
  } else {
    // Interactive mode
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
    });

    try {
      config = await promptConfig(rl);
    } finally {
      rl.close();
    }
  }

  // Validate
  const errors = [
    ...validatePluginId(config.id),
    ...validatePluginName(config.name),
    ...validateDescription(config.description),
  ];

  if (errors.length > 0) {
    console.error('');
    console.error('Validation errors:');
    for (const err of errors) {
      console.error(`  - ${err}`);
    }
    process.exit(1);
  }

  // Generate files
  const outputDir = args.dir || path.join(process.cwd(), config.id);

  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  let created = 0;
  let skipped = 0;

  for (const [filename, generator] of Object.entries(TEMPLATE_FILES)) {
    const filePath = path.join(outputDir, filename);

    if (fs.existsSync(filePath)) {
      console.log(`  [skip] ${filename} (already exists)`);
      skipped++;
      continue;
    }

    const content = generator(config);
    fs.writeFileSync(filePath, content, 'utf8');
    console.log(`  [create] ${filename}`);
    created++;
  }

  console.log('');
  console.log(`Done! Created ${created} file(s), skipped ${skipped} existing file(s).`);
  console.log(`Output directory: ${outputDir}`);
  console.log('');
  console.log('Next steps:');
  console.log(`  cd ${path.relative(process.cwd(), outputDir) || '.'}`);
  console.log('  npm install');
  console.log('  npm run dev');
  console.log('');
}

async function promptConfig(rl) {
  let id;
  while (true) {
    id = await ask(rl, 'Plugin ID (lowercase, hyphens, e.g. "daily-notes-companion"): ');
    const errors = validatePluginId(id);
    if (errors.length === 0) break;
    for (const err of errors) console.log(`  Error: ${err}`);
  }

  let name;
  while (true) {
    name = await ask(rl, 'Plugin name (display name, e.g. "Daily Notes Companion"): ');
    const errors = validatePluginName(name);
    if (errors.length === 0) break;
    for (const err of errors) console.log(`  Error: ${err}`);
  }

  let description;
  while (true) {
    description = await ask(rl, 'Description (must end with punctuation): ');
    const errors = validateDescription(description);
    if (errors.length === 0) break;
    for (const err of errors) console.log(`  Error: ${err}`);
  }

  const author = await ask(rl, 'Author name: ');
  const authorUrl = await ask(rl, 'Author URL (optional): ');

  return { id, name, description, author, authorUrl };
}

function detectExistingFiles(dir) {
  if (!fs.existsSync(dir)) return [];
  return Object.keys(TEMPLATE_FILES).filter((f) => fs.existsSync(path.join(dir, f)));
}

function parseArgs(argv) {
  const args = {};
  for (let i = 0; i < argv.length; i++) {
    switch (argv[i]) {
      case '--dir':
        args.dir = argv[++i];
        break;
      case '--id':
        args.id = argv[++i];
        break;
      case '--name':
        args.name = argv[++i];
        break;
      case '--desc':
        args.desc = argv[++i];
        break;
      case '--author':
        args.author = argv[++i];
        break;
      case '--author-url':
        args.authorUrl = argv[++i];
        break;
    }
  }
  return args;
}

main().catch((err) => {
  console.error('Error:', err);
  process.exit(1);
});
